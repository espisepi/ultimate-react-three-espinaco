import{Vector3 as t,Vector2 as i,Box3 as n,BufferAttribute as s,BufferGeometry as e}from"three";function r(t,i,n,s){return function(t,i,n,s,e){let r={x:i.x-t.x,y:i.y-t.y},a={x:s.x-n.x,y:s.y-n.y};const o=h(t),l=h(n);if(o===l)return e;const u=h(i);if(u===l)return e;const g=h(s);if(o===g)return e;if(u===g)return e;let c=(t.x-n.x)*a.y-(t.y-n.y)*a.x,d=(i.x-n.x)*a.y-(i.y-n.y)*a.x,p=(n.x-t.x)*r.y-(n.y-t.y)*r.x,f=(s.x-t.x)*r.y-(s.y-t.y)*r.x;return(c>=0&&d<=0||c<=0&&d>=0)&&(p>=0&&f<=0||p<=0&&f>=0)}(t,i,n,s,!1)}function a(i,n,s,e){let r=0,a=new t;return l(i)===l(n)||0===s.x&&0===s.y&&0===s.z?null:(r=((e.x-i.x)*s.x+(e.y-i.y)*s.y+(e.z-i.z)*s.z)/((n.x-i.x)*s.x+(n.y-i.y)*s.y+(n.z-i.z)*s.z),r>=0&&r<=1?(a=new t(i.x+(n.x-i.x)*r,i.y+(n.y-i.y)*r,i.z+(n.z-i.z)*r),{x:a,s:r}):null)}function o(t,i,n){return(i.x-t.x)*(n.y-t.y)-(i.y-t.y)*(n.x-t.x)<=0}function h(t,i=1e6){const n=Math.floor(t.x*i),s=Math.floor(t.y*i);return(n+s)*(n+s+1)*.5+s}function l(t,i=1e6){const n=Math.floor(t.x*i),s=Math.floor(t.y*i),e=Math.floor(t.z*i),r=(n+s)*(n+s+1)*.5+s;return(r+e)*(r+e+1)*.5+e}function u(t,i,n){return i.x*(t.x-n.x)+i.y*(t.y-n.y)+i.z*(t.z-n.z)>=0}class g{constructor(n=new t,s=new t,e=new i){this.position=n,this.normal=s,this.uv=e}hash(t=1e6){const i=Math.floor(this.position.x*t),n=Math.floor(this.position.y*t),s=Math.floor(this.position.z*t),e=(i+n)*(i+n+1)*.5+n;return(e+s)*(e+s+1)*.5/2+s}equals(t,i=1e-9){return this.hash(i)===t.hash(i)}toString(){return`Position = ${this.position.x}, ${this.position.y}, ${this.position.z}, Normal = ${this.normal.x}, ${this.normal.y}, ${this.normal.z}, UV = ${this.uv.x}, ${this.uv.y}`}}const c=0,d=1;class p{constructor(){this.vertices=[],this.cutVertices=[],this.triangles=[[],[]],this.constraints=[],this.indexMap=[],this.bounds=new n,this.vertexAdjacency=[]}static fromGeometry(n){var s=n.attributes.position.array,e=n.attributes.normal.array,r=n.attributes.uv.array;const a=new p;for(let n=0;n<s.length/3;n++){const o=new t(s[3*n],s[3*n+1],s[3*n+2]),h=new t(e[3*n],e[3*n+1],e[3*n+2]),l=new i(r[2*n],r[2*n+1]);a.vertices.push(new g(o,h,l))}return a.triangles=[new Uint32Array(n.index?.array),[]],a.calculateBounds(),a}get triangleCount(){return(this.triangles[0].length+this.triangles[1].length)/3}get vertexCount(){return this.vertices.length+this.cutVertices.length}addCutFaceVertex(t,i,n){const s=new g(t,i,n);this.vertices.push(s),this.cutVertices.push(s),this.vertexAdjacency.push(this.vertices.length-1)}addMappedVertex(t,i){this.vertices.push(t),this.indexMap[i]=this.vertices.length-1}addTriangle(t,i,n,s){this.triangles[s].push(t,i,n)}addMappedTriangle(t,i,n,s){this.triangles[s].push(this.indexMap[t],this.indexMap[i],this.indexMap[n])}weldCutFaceVertices(){const t=[],i=[],n=new Array(this.cutVertices.length);let s=0;const e=new Map;this.cutVertices.forEach(((r,a)=>{const o=r.hash();e.has(o)?n[a]=e.get(o):(n[a]=s,e.set(o,s),t.push(this.cutVertices[a]),i.push(this.vertexAdjacency[a]),s++)}));for(let t=0;t<this.constraints.length;t++){const i=this.constraints[t];i.v1=n[i.v1],i.v2=n[i.v2]}this.cutVertices=t,this.vertexAdjacency=i}calculateBoundsTest(){const t=this.vertices.length,i=new Array(3*t);let e=-1;for(const t of this.vertices)i[e++]=t.position.x,i[e++]=t.position.y,i[e++]=t.position.z;let r=new s(new Float32Array(i));this.bounds=(new n).setFromBufferAttribute(r)}calculateBounds(){let t=this.vertices[0].position.clone(),i=t.clone();this.vertices.forEach((n=>{t.x=Math.min(t.x,n.position.x),t.y=Math.min(t.y,n.position.y),t.z=Math.min(t.z,n.position.z),i.x=Math.max(i.x,n.position.x),i.y=Math.max(i.y,n.position.y),i.z=Math.max(i.z,n.position.z)})),this.bounds=new n(t,i)}toGeometry(){const t=new e,i=this.vertices.length+this.cutVertices.length,n=new Array(3*i),r=new Array(3*i),a=new Array(2*i);let o=0,h=0,l=0;for(const t of this.vertices)n[o++]=t.position.x,n[o++]=t.position.y,n[o++]=t.position.z,r[h++]=t.normal.x,r[h++]=t.normal.y,r[h++]=t.normal.z,a[l++]=t.uv.x,a[l++]=t.uv.y;for(const t of this.cutVertices)n[o++]=t.position.x,n[o++]=t.position.y,n[o++]=t.position.z,r[h++]=t.normal.x,r[h++]=t.normal.y,r[h++]=t.normal.z,a[l++]=t.uv.x,a[l++]=t.uv.y;return t.addGroup(0,this.triangles[0].length,0),t.addGroup(this.triangles[0].length,this.triangles[1].length,1),t.setAttribute("position",new s(new Float32Array(n),3)),t.setAttribute("normal",new s(new Float32Array(r),3)),t.setAttribute("uv",new s(new Float32Array(a),2)),t.setIndex(new s(new Uint32Array(this.triangles.flat()),1)),t}}class f{constructor(t){this.parent=new Array(t),this.rank=new Array(t);for(let i=0;i<t;i++)this.parent[i]=i,this.rank[i]=1}find(t){return this.parent[t]!==t&&(this.parent[t]=this.find(this.parent[t])),this.parent[t]}union(t,i){const n=this.find(t),s=this.find(i);n!==s&&(this.rank[n]>this.rank[s]?this.parent[s]=n:this.rank[n]<this.rank[s]?this.parent[n]=s:(this.parent[s]=n,this.rank[n]+=1))}}class x{constructor(t,i,n,s,e){this.v1=t,this.v2=i,this.t1=n??-1,this.t2=s??-1,this.t1Edge=e??0}equals(t){return this.v1===t.v1&&this.v2===t.v2||this.v1===t.v2&&this.v2===t.v1}toString(){return`Edge: T${this.t1}->T${this.t2} (V${this.v1}->V${this.v2})`}}class y{static getBinNumber(t,i,n){return t%2==0?t*n+i:(t+1)*n-i-1}static sort(t,i,n){if(n<=1)return t;i>t.length&&(i=t.length);const s=new Array(n).fill(0),e=new Array(t.length);for(let n=0;n<i;n++)s[t[n].bin]++;for(let t=1;t<n;t++)s[t]+=s[t-1];for(let n=i-1;n>=0;n--){const i=t[n].bin;s[i]--,e[s[i]]=t[n]}for(let n=i;n<e.length;n++)e[n]=t[n];return e}}class v{constructor(t,i){this.index=t,this.coords=i,this.bin=0}toString(){return`${this.coords} -> ${this.bin}`}}const w=-1;class m{constructor(n,s){if(this.normalizationScaleFactor=1,this.N=n.length,this.N>=3){this.triangleCount=2*this.N+1,this.triangulation=Array.from({length:this.triangleCount},(()=>new Array(6).fill(0))),this.skipTriangle=new Array(this.triangleCount).fill(!1),this.points=new Array(this.N+3),this.normal=s.clone().normalize();let a=n[0].position.clone().sub(n[1].position).normalize(),o=this.normal.clone(),h=new t;h.crossVectors(a,o).normalize();for(let t=0;t<this.N;t++){var e=n[t].position,r=new i(e.dot(a),e.dot(h));this.points[t]=new v(t,r)}}else this.triangleCount=0,this.triangulation=[],this.skipTriangle=[],this.points=[],this.normal=new t}triangulate(){if(this.N<3)return[];this.addSuperTriangle(),this.normalizeCoordinates(),this.computeTriangulation(),this.discardTrianglesWithSuperTriangleVertices();const t=[];for(let i=0;i<this.triangleCount;i++)this.skipTriangle[i]||t.push(this.triangulation[i][0],this.triangulation[i][1],this.triangulation[i][2]);return t}normalizeCoordinates(){let t=Number.MAX_VALUE,n=Number.MIN_VALUE,s=Number.MAX_VALUE,e=Number.MIN_VALUE;for(let i=0;i<this.N;i++)t=Math.min(t,this.points[i].coords.x),n=Math.max(n,this.points[i].coords.x),s=Math.min(s,this.points[i].coords.y),e=Math.max(e,this.points[i].coords.y);const r=Math.max(n-t,e-s);for(let n=0;n<this.N;n++){var a=this.points[n],o=new i((a.coords.x-t)/r,(a.coords.y-s)/r);this.points[n].coords=o}}sortPointsIntoBins(){const t=Math.round(Math.pow(this.N,.25)),i=t*t;for(let i=0;i<this.N;i++){var n=this.points[i];const s=Math.floor(.99*t*n.coords.y),e=Math.floor(.99*t*n.coords.x);n.bin=y.getBinNumber(s,e,t)}return y.sort(this.points,this.N,i)}computeTriangulation(){let t=0,i=0,n=this.sortPointsIntoBins();for(let s=0;s<this.N;s++){let e=n[s],r=0,a=!1;for(;!a&&!(r++>i||t===w);){let n=this.points[this.triangulation[t][0]].coords,s=this.points[this.triangulation[t][1]].coords,r=this.points[this.triangulation[t][2]].coords;o(n,s,e.coords)?o(s,r,e.coords)?o(r,n,e.coords)?(this.insertPointIntoTriangle(e,t,i),i+=2,t=i,a=!0):t=this.triangulation[t][5]:t=this.triangulation[t][4]:t=this.triangulation[t][3]}}}addSuperTriangle(){this.points[this.N]=new v(this.N,new i(-100,-100)),this.points[this.N+1]=new v(this.N+1,new i(0,100)),this.points[this.N+2]=new v(this.N+2,new i(100,-100)),this.triangulation[0][0]=this.N,this.triangulation[0][1]=this.N+1,this.triangulation[0][2]=this.N+2,this.triangulation[0][3]=w,this.triangulation[0][4]=w,this.triangulation[0][5]=w}insertPointIntoTriangle(t,i,n){const s=i,e=n+1,r=n+2;this.triangulation[e][0]=t.index,this.triangulation[e][1]=this.triangulation[i][1],this.triangulation[e][2]=this.triangulation[i][2],this.triangulation[e][3]=r,this.triangulation[e][4]=this.triangulation[i][4],this.triangulation[e][5]=s,this.triangulation[r][0]=t.index,this.triangulation[r][1]=this.triangulation[i][0],this.triangulation[r][2]=this.triangulation[i][1],this.triangulation[r][3]=s,this.triangulation[r][4]=this.triangulation[i][3],this.triangulation[r][5]=e,this.updateAdjacency(this.triangulation[i][3],i,r),this.updateAdjacency(this.triangulation[i][4],i,e),this.triangulation[s][1]=this.triangulation[i][2],this.triangulation[s][2]=this.triangulation[i][0],this.triangulation[s][0]=t.index,this.triangulation[s][4]=this.triangulation[i][5],this.triangulation[s][3]=e,this.triangulation[s][5]=r,this.restoreDelauneyTriangulation(t,s,e,r)}restoreDelauneyTriangulation(t,i,n,s){const e=[];for(e.push([i,this.triangulation[i][4]]),e.push([n,this.triangulation[n][4]]),e.push([s,this.triangulation[s][4]]);e.length>0;)if([i,n]=e.pop()??[w,w],n!=w){const s=this.swapQuadDiagonalIfNeeded(t.index,i,n);s&&(e.push([i,s.t3]),e.push([n,s.t4]))}}swapQuadDiagonalIfNeeded(t,i,n){let s=0,e=0,r=0,a=t,o=0,h=0;this.triangulation[n][3]===i?(s=this.triangulation[n][1],e=this.triangulation[n][0],r=this.triangulation[n][2],o=this.triangulation[n][4],h=this.triangulation[n][5]):this.triangulation[n][4]===i?(s=this.triangulation[n][2],e=this.triangulation[n][1],r=this.triangulation[n][0],o=this.triangulation[n][5],h=this.triangulation[n][3]):(s=this.triangulation[n][0],e=this.triangulation[n][2],r=this.triangulation[n][1],o=this.triangulation[n][3],h=this.triangulation[n][4]);return this.swapTest(this.points[s].coords,this.points[e].coords,this.points[r].coords,this.points[a].coords)?(this.updateAdjacency(o,n,i),this.updateAdjacency(this.triangulation[i][5],i,n),this.triangulation[i][0]=a,this.triangulation[i][1]=s,this.triangulation[i][2]=r,this.triangulation[n][0]=a,this.triangulation[n][1]=r,this.triangulation[n][2]=e,this.triangulation[n][3]=i,this.triangulation[n][4]=h,this.triangulation[n][5]=this.triangulation[i][5],this.triangulation[i][4]=o,this.triangulation[i][5]=n,{t3:o,t4:h}):null}discardTrianglesWithSuperTriangleVertices(){for(let t=0;t<this.triangleCount;t++)(this.triangleContainsVertex(t,this.N)||this.triangleContainsVertex(t,this.N+1)||this.triangleContainsVertex(t,this.N+2))&&(this.skipTriangle[t]=!0)}swapTest(t,i,n,s){const e=t.x-n.x,r=i.x-n.x,a=t.y-n.y,o=i.y-n.y,h=t.x-s.x,l=i.x-s.x,u=t.y-s.y,g=i.y-s.y,c=e*r+a*o,d=l*h+g*u;if(c>=0&&d>=0)return!1;if(c<0&&d<0)return!0;return(e*o-r*a)*d+(l*u-h*g)*c<0}triangleContainsVertex(t,i){return this.triangulation[t][0]===i||this.triangulation[t][1]===i||this.triangulation[t][2]===i}updateAdjacency(t,i,n){if(t===w)return;const s=this.findSharedEdge(t,i);s&&(this.triangulation[t][s]=n)}findSharedEdge(t,i){return t===w?null:this.triangulation[t][3]===i?3:this.triangulation[t][4]===i?4:this.triangulation[t][5]===i?5:null}}class V{constructor(t,i,n,s,e,r,a,o,h,l){this.q1=t,this.q2=i,this.q3=n,this.q4=s,this.t1=e,this.t2=r,this.t1L=a,this.t1R=o,this.t2L=h,this.t2R=l}toString(){return`T${this.t1}/T${this.t2} (V${this.q1},V${this.q2},V${this.q3},V${this.q4})`}}class T extends m{edgeVertex1=[0,0,0,0,1,2];edgeVertex2=[0,0,0,1,2,0];oppositePoint=[0,0,0,2,0,1];nextEdge=[0,0,0,4,5,3];previousEdge=[0,0,0,5,3,4];constructor(t,i,n){super(t,n),this.constraints=i,this.vertexTriangles=[]}triangulate(){if(this.N<3)return[];this.addSuperTriangle(),this.normalizeCoordinates(),this.computeTriangulation(),this.constraints.length>0&&(this.applyConstraints(),this.discardTrianglesViolatingConstraints()),this.discardTrianglesWithSuperTriangleVertices();let t=[];for(let i=0;i<this.triangleCount;i++)this.skipTriangle[i]||(t.push(this.triangulation[i][0]),t.push(this.triangulation[i][1]),t.push(this.triangulation[i][2]));return t}applyConstraints(){this.vertexTriangles=new Array(this.N+3).fill(0);for(let t=0;t<this.triangulation.length;t++)this.vertexTriangles[this.triangulation[t][0]]=t,this.vertexTriangles[this.triangulation[t][1]]=t,this.vertexTriangles[this.triangulation[t][2]]=t;for(let t of this.constraints){if(t.v1===t.v2)continue;const i=this.findIntersectingEdges(t,this.vertexTriangles);this.removeIntersectingEdges(t,i)}}findIntersectingEdges(t,i){const n=[],s=this.findStartingEdge(i,t);if(!s)return n;n.push(s);let e=s.t1,a=s.t1Edge,o=e,h=!1;for(;!h;){o=e,e=this.triangulation[e][a];const i=this.points[t.v1].coords,s=this.points[t.v2].coords,u=this.points[this.triangulation[e][0]].coords,g=this.points[this.triangulation[e][1]].coords,c=this.points[this.triangulation[e][2]].coords;if(this.triangleContainsVertex(e,t.v2))h=!0;else if(this.triangulation[e][3]!==o&&r(i,s,u,g)){a=3;var l=new x(this.triangulation[e][0],this.triangulation[e][1],e,this.triangulation[e][3],a);n.push(l)}else if(this.triangulation[e][4]!==o&&r(i,s,g,c)){a=4;l=new x(this.triangulation[e][1],this.triangulation[e][2],e,this.triangulation[e][4],a);n.push(l)}else{if(this.triangulation[e][5]===o||!r(i,s,c,u)){console.warn("Failed to find final triangle, exiting early.");break}a=5;l=new x(this.triangulation[e][2],this.triangulation[e][0],e,this.triangulation[e][5],a);n.push(l)}}return n}findStartingEdge(t,i){let n,s,e,r=new x(-1,-1),a=i.v1,o=t[a],h=!1,l=null;const u=new Array(this.triangulation.length);for(;!l&&!h;){if(u[o]=!0,this.triangleContainsConstraint(o,i))return null;if(l=this.edgeConstraintIntersectsTriangle(o,i),l)break;if(n=this.triangulation[o][3],s=this.triangulation[o][4],e=this.triangulation[o][5],-1!==n&&!u[n]&&this.triangleContainsVertex(n,a))o=n;else if(-1!==s&&!u[s]&&this.triangleContainsVertex(s,a))o=s;else{if(-1===e||u[e]||!this.triangleContainsVertex(e,a)){h=!0;break}o=e}}if(l){const t=this.triangulation[o][this.edgeVertex1[l]],i=this.triangulation[o][this.edgeVertex2[l]],n=this.triangulation[o][l];return r=new x(t,i,o,n,l),r}return null}removeIntersectingEdges(t,i){let n,s=[],e=0;for(;i.length>0&&e<=i.length;){if(n=i.shift(),null==n)continue;let a=this.findQuadFromSharedEdge(n.t1,n.t1Edge);if(a)if(r(this.points[a.q4].coords,this.points[a.q3].coords,this.points[a.q1].coords,this.points[a.q2].coords)){this.swapQuadDiagonal(a,i,s,this.constraints);let n=new x(a.q3,a.q4,a.t1,a.t2,5);r(this.points[t.v1].coords,this.points[t.v2].coords,this.points[a.q3].coords,this.points[a.q4].coords)?i.push(n):(e=0,s.push(n))}else i.push(n);e++}s.length>0&&this.restoreConstrainedDelauneyTriangulation(t,s)}restoreConstrainedDelauneyTriangulation(t,i){let n=!0;for(;n;){n=!1;for(let s=0;s<i.length;s++){const e=i[s];if(e.equals(t))continue;let r=this.findQuadFromSharedEdge(e.t1,e.t1Edge);if(r&&this.swapTest(this.points[r.q1].coords,this.points[r.q2].coords,this.points[r.q3].coords,this.points[r.q4].coords)){this.swapQuadDiagonal(r,i,this.constraints,null);const t=r.q3,e=r.q4;i[s]=new x(t,e,r.t1,r.t2,5),n=!0}}}}discardTrianglesViolatingConstraints(){function t(t,i){return(t+i)*(t+i+1)/2+i}this.skipTriangle.fill(!0);let i=new Set;for(let n=0;n<this.constraints.length;n++){const s=this.constraints[n];i.add(t(s.v1,s.v2))}let n,s,e,r,a,o,h=[];const l=new Array(this.triangulation.length);for(let u=0;u<this.triangleCount;u++)if(!l[u]&&(n=this.triangulation[u][0],s=this.triangulation[u][1],e=this.triangulation[u][2],r=i.has(t(n,s)),a=i.has(t(s,e)),o=i.has(t(e,n)),r||a||o))for(this.skipTriangle[u]=!1,h=[],r||h.push(this.triangulation[u][3]),a||h.push(this.triangulation[u][4]),o||h.push(this.triangulation[u][5]);h.length>0;){const r=h.shift();r&&-1!==r&&!l[r]&&(this.skipTriangle[r]=!1,l[r]=!0,n=this.triangulation[r][0],s=this.triangulation[r][1],e=this.triangulation[r][2],i.has(t(n,s))||h.push(this.triangulation[r][3]),i.has(t(s,e))||h.push(this.triangulation[r][4]),i.has(t(e,n))||h.push(this.triangulation[r][5]))}}triangleContainsConstraint(t,i){return!(t>=this.triangulation.length)&&!(this.triangulation[t][0]!==i.v1&&this.triangulation[t][1]!==i.v1&&this.triangulation[t][2]!==i.v1||this.triangulation[t][0]!==i.v2&&this.triangulation[t][1]!==i.v2&&this.triangulation[t][2]!==i.v2)}edgeConstraintIntersectsTriangle(t,i){const n=this.points[i.v1].coords,s=this.points[i.v2].coords,e=this.points[this.triangulation[t][0]].coords,a=this.points[this.triangulation[t][1]].coords,o=this.points[this.triangulation[t][2]].coords;return r(n,s,e,a)?3:r(n,s,a,o)?4:r(n,s,o,e)?5:null}findQuadFromSharedEdge(t,i){let n,s,e,r,a,o,h,l,u=this.triangulation[t][i],g=this.findSharedEdge(u,t);return g?(3===g?(s=this.triangulation[u][0],n=this.triangulation[u][1],e=this.triangulation[u][2]):4===g?(s=this.triangulation[u][1],n=this.triangulation[u][2],e=this.triangulation[u][0]):(s=this.triangulation[u][2],n=this.triangulation[u][0],e=this.triangulation[u][1]),r=this.triangulation[t][this.oppositePoint[i]],a=this.triangulation[t][this.previousEdge[i]],o=this.triangulation[t][this.nextEdge[i]],h=this.triangulation[u][this.nextEdge[g]],l=this.triangulation[u][this.previousEdge[g]],new V(n,s,e,r,t,u,a,o,h,l)):null}swapQuadDiagonal(t,i,n,s){const e=t.t1,r=t.t2,a=t.t1R,o=t.t1L,h=t.t2R,l=t.t2L;this.triangulation[e][0]=t.q4,this.triangulation[e][1]=t.q1,this.triangulation[e][2]=t.q3,this.triangulation[r][0]=t.q4,this.triangulation[r][1]=t.q3,this.triangulation[r][2]=t.q2,this.triangulation[e][3]=o,this.triangulation[e][4]=l,this.triangulation[e][5]=r,this.triangulation[r][3]=e,this.triangulation[r][4]=h,this.triangulation[r][5]=a,this.updateAdjacency(l,r,e),this.updateAdjacency(a,e,r),this.updateEdgesAfterSwap(i,e,r,o,a,l,h),this.updateEdgesAfterSwap(n,e,r,o,a,l,h),this.updateEdgesAfterSwap(s,e,r,o,a,l,h),this.vertexTriangles[t.q1]=e,this.vertexTriangles[t.q2]=r}updateEdgesAfterSwap(t,i,n,s,e,r,a){if(t)for(let o of t)o.t1===i&&o.t2===e?(o.t1=n,o.t2=e,o.t1Edge=5):o.t1===i&&o.t2===s?o.t1Edge=3:o.t1===e&&o.t2===i?o.t2=n:o.t1===s&&o.t2===i||(o.t1===n&&o.t2===a?o.t1Edge=4:o.t1===n&&o.t2===r?(o.t1=i,o.t2=r,o.t1Edge=4):o.t1===a&&o.t2===n||o.t1===r&&o.t2===n&&(o.t2=i))}}function M(t,n,s,e,r,a){const o=new p,h=new p,l=new Array(t.vertexCount).fill(!1);for(let i=0;i<t.vertices.length;i++){var f=t.vertices[i];l[i]=u(f.position,n,s),(l[i]?o:h).addMappedVertex(f,i)}const x=t.vertices.length;for(let i=0;i<t.cutVertices.length;i++){f=t.cutVertices[i];l[i+x]=u(f.position,n,s),(l[i+x]?o:h).addMappedVertex(f,i+x)}return A(t,o,h,n,s,l,c),A(t,o,h,n,s,l,d),function(t,n,s,e,r,a){if(t.weldCutFaceVertices(),t.cutVertices.length<3)return;const o=a?new m(t.cutVertices,s):new T(t.cutVertices,t.constraints,s),h=o.triangulate();for(let a=0;a<t.cutVertices.length;a++){var l=t.cutVertices[a],u=o.points[a];const h=new i(o.normalizationScaleFactor*u.coords.x*e.x+r.x,o.normalizationScaleFactor*u.coords.y*e.y+r.y),c=new g(l.position.clone(),s.clone(),h.clone()),d=new g(l.position.clone(),s.clone().negate(),h.clone());t.cutVertices[a]=c,n.cutVertices[a]=d}let c=t.vertices.length,p=n.vertices.length;for(let i=0;i<h.length;i+=3)t.addTriangle(c+h[i],c+h[i+1],c+h[i+2],d),n.addTriangle(p+h[i],p+h[i+2],p+h[i+1],d)}(o,h,n.clone().negate(),e,r,a),{topSlice:o,bottomSlice:h}}function A(t,i,n,s,e,r,a){const o=t.triangles[a];let h,l,u;for(let g=0;g<o.length;g+=3)h=o[g],l=o[g+1],u=o[g+2],r[h]&&r[l]&&r[u]?i.addMappedTriangle(h,l,u,a):r[h]||r[l]||r[u]?r[l]&&r[u]&&!r[h]?z(l,u,h,s,e,t,i,n,a,!0):r[u]&&r[h]&&!r[l]?z(u,h,l,s,e,t,i,n,a,!0):r[h]&&r[l]&&!r[u]?z(h,l,u,s,e,t,i,n,a,!0):r[l]||r[u]||!r[h]?r[u]||r[h]||!r[l]?r[h]||r[l]||!r[u]||z(h,l,u,s,e,t,i,n,a,!1):z(u,h,l,s,e,t,i,n,a,!1):z(l,u,h,s,e,t,i,n,a,!1):n.addMappedTriangle(h,l,u,a)}function z(n,s,e,r,o,h,l,u,g,c){let d=n<h.vertices.length?h.vertices[n]:h.cutVertices[n-h.vertices.length],p=s<h.vertices.length?h.vertices[s]:h.cutVertices[s-h.vertices.length],f=e<h.vertices.length?h.vertices[e]:h.cutVertices[e-h.vertices.length];const y=a(d.position,f.position,r,o),v=a(p.position,f.position,r,o);if(y&&v){const r=new t(d.normal.x+y.s*(f.normal.x-d.normal.x),d.normal.y+y.s*(f.normal.y-d.normal.y),d.normal.z+y.s*(f.normal.z-d.normal.z)).normalize(),a=new t(p.normal.x+v.s*(f.normal.x-p.normal.x),p.normal.y+v.s*(f.normal.y-p.normal.y),p.normal.z+v.s*(f.normal.z-p.normal.z)).normalize(),o=new i(d.uv.x+y.s*(f.uv.x-d.uv.x),d.uv.y+y.s*(f.uv.y-d.uv.y)),h=new i(p.uv.x+v.s*(f.uv.x-p.uv.x),p.uv.y+v.s*(f.uv.y-p.uv.y));l.addCutFaceVertex(y.x,r,o),l.addCutFaceVertex(v.x,a,h),u.addCutFaceVertex(y.x,r,o),u.addCutFaceVertex(v.x,a,h);const w=l.vertices.length-2,m=l.vertices.length-1,V=u.vertices.length-2,T=u.vertices.length-1;c?(l.addTriangle(m,w,l.indexMap[s],g),l.addTriangle(w,l.indexMap[n],l.indexMap[s],g),u.addTriangle(u.indexMap[e],V,T,g),l.constraints.push(new x(l.cutVertices.length-2,l.cutVertices.length-1)),u.constraints.push(new x(u.cutVertices.length-1,u.cutVertices.length-2))):(l.addTriangle(w,m,l.indexMap[e],g),u.addTriangle(u.indexMap[n],u.indexMap[s],V,g),u.addTriangle(u.indexMap[s],T,V,g),l.constraints.push(new x(l.cutVertices.length-1,l.cutVertices.length-2)),u.constraints.push(new x(u.cutVertices.length-2,u.cutVertices.length-1)))}}const C={fragmentCount:50,fracturePlanes:{x:!0,y:!0,z:!0},fractureMode:"Convex",textureScale:new i(1,1),textureOffset:new i};function N(i,n){const s={...C,...n};let e=[p.fromGeometry(i.geometry)];for(;e.length<s.fragmentCount;){const i=e.shift();if(!i)continue;i?.calculateBounds();let n=new t(s.fracturePlanes.x?2*Math.random()-1:0,s.fracturePlanes.y?2*Math.random()-1:0,s.fracturePlanes.z?2*Math.random()-1:0).normalize(),r=new t;if(i.bounds.getCenter(r),"Non-Convex"===s.fractureMode){const{topSlice:t,bottomSlice:a}=M(i,n,r,s.textureScale,s.textureOffset,!1),o=E(t),h=E(a);e.push(...o),e.push(...h)}else{const{topSlice:t,bottomSlice:a}=M(i,n,r,s.textureScale,s.textureOffset,!0);e.push(t),e.push(a)}}return e}function E(t){const i=new f(t.vertexCount),n={},s=t.vertices.length,e=t.cutVertices.length,r=new Map;t.vertices.forEach(((t,n)=>{const s=t.hash(),e=r.get(s);void 0===e?r.set(s,n):i.union(e,n)}));for(let n=0;n<e;n++)i.union(t.vertexAdjacency[n],n+s);const a=t.triangles;for(let t=0;t<a.length;t++)for(let s=0;s<a[t].length;s+=3){const e=a[t][s],r=a[t][s+1],o=a[t][s+2];i.union(e,r),i.union(r,o);const h=i.find(e);n[h]||(n[h]=[[],[]]),n[h][t].push(e,r,o)}const o={},h=Array(t.vertexCount);for(let n=0;n<s;n++){const s=i.find(n);o[s]||(o[s]=new p),o[s].vertices.push(t.vertices[n]),h[n]=o[s].vertices.length-1}for(let n=0;n<e;n++){const e=i.find(n+s);o[e].cutVertices.push(t.cutVertices[n]),h[n+s]=o[e].vertices.length+o[e].cutVertices.length-1}for(const s of Object.keys(n)){let e=Number(s),r=i.parent[e];for(let i=0;i<t.triangles.length;i++)for(const t of n[e][i]){const n=h[t];o[r].triangles[i].push(n)}}return Object.values(o)}export{N as Fracture,M as Slice,C as option};
